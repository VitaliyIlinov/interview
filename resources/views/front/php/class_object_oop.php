Источники&raquo;
<a class="btn btn-secondary" target="_blank" href="https://devionity.com/ru/courses/php-oop/" role="button">
    devionity
</a>
<h2>Класс и объекты</h2>
<p><b><em>Класс</em></b> - это некий шаблон, экземпляры которого можно создавать. Часто говорят об отдельном классе как
    об отдельном
    типе данных. В классе определены т.н. <em>свойства</em> и <em>методы</em>.

</p>
<p><b><em>Свойства</em></b> класса - это переменные внутри класса, а <b>методы</b> класса - это функции внутри класса.
</p>
<p>
    <b><em>Объект</em></b> - это экземпляр класса. Часто говорят, что класс - это как тип данных, а объект - это как
    переменная этого
    типа. Соответственно мы может создать много экземпляров одного класса, так же как и создать много переменных одного
    типа
</p>

<h2>Принципы ООП</h2>
<p>Основные принципы ООП, которыми являются <b><em>инкапсуляция, наследование и полиморфизм</em></b>
</p>
<ul>
    <li><b><em>инкапсуляция</em></b> - это свойство объекта/класса регулировать доступ к определенным своим компонентам
        извне самого объекта/класса.
    </li>
    <li><b><em>Наследование</em></b> - это свойство классов расширяться.</li>
    <li><b><em>Полиморфизм</em></b> - это следствие наследования. Это свойство унаследованных классов иметь одинаковые
        методы, которые будут работать по-разному в контексте объектов. Например, у нас есть класс фигура и классы
        квадрат, треугольник и трапеция - унаследованные от фигуры. Каждая фигура содержит функционал для вычисления
        площади, но у каждой фигуры он свой.
    </li>
</ul>
<pre>
    <code class="php">
        abstract class Publication {
            // определяем правило, что все публикации должны печататься, т.е. иметь метод do_print()
            abstract protected function do_print();
            // испольузем final чтобы инкапсулировать логику работы данного метода
            final protected function getClassName(){ return __CLASS__; }
        }

        class News extends Publication {
           // переопределяем абстрактный метод печати
           public function do_print() {
               echo 'Новость';
           }
        }
        class Announcement extends Publication {
            // переопределяем абстрактный метод печати
            public function do_print() {
                echo 'Объявление';
            }
        }

        //Наполняем массив публикаций объектами, производными от Publication
        $publications[] = new News();
        $publications[] = new Announcement();
        // пример полиморфизма:
        foreach ($publications as $publication) {
            if ($publication instanceof Publication) { // Если мы работаем с наследниками Publication
                $publication->do_print(); // то мы можем смело выводить данные на печать
            } else {
                //исключение или обработка ошибки
            }
        }
        function printPublicationName(Publication $publication){
            // пример использования метода, который инкапсулирован:
            $publication->getClassName();
        }
        printPublicationName(new News());
        printPublicationName(new Announcement());
    </code>
</pre>

<h2>Ссылка на объект ($this)</h2>
<p>
    Переменная <b><em>$this</em></b> - это специальная переменная, которая используется для доступа к объекту класса
    изнутри самогокласса. Фактически, эта переменная будет содержать ссылку на объект класса.
</p>

<h2>Статические свойства</h2>
<p>
    <b><em>Статические</em></b> свойства класса - это свойства, к которым можно обращаться без создания объекта -
    в контексте самого класса. Статические свойства объявляются при определении класса при помощи специального слова
    static, которое записывается после спецификатора доступа public / protected / private
</p>
<p>
    Для обращения к константам класса, статическим свойствам и статическим методам класса изнутри самого класса (т.е.
    при реализации методов класса) необходимо использовать ключевое слово <b><em>self</b></em>. После этого ключевого
    слова записывается
    оператор :: , который позволяет обратиться к константам, статическим свойствам или статическим методам класса.
</p>
<p>
    Ключевое слово self употребляется исключительно внутри класса и, фактически, является синонимом названия текущего
    класса.
</p>
<p>
    Не путайте $this (обращение к свойствам/методам в контексте объекта) и self (обращение к статическим
    свойствам/методам/константам в контексте класса).

<p>
    При определении дочернего класса, для обращения к константам, статическим свойствам и методам родительского класса
    необходимо использовать ключевое слово parent
</p>
<pre>
    <code class="php">
class A
{
    const SOME_CONSTANT = 512;
    private static $x;

    public static function setX($str)
    {
        self::$x = $str;
    }

    public static function getX()
    {
        return self::$x;
    }
}

class B extends A
{
    static public function test()
    {
        parent::setX('Hello');
        echo parent::getX();
        echo parent::SOME_CONSTANT;
    }

}
    </code>
</pre>
<p>
    Ключевое слово static используется для доступа к статическим свойствам и методам из контекста самого класса изнутри
    класса (например как self, parent).
</p>
<pre>
    <code class="php">
class A
{
	public static function test()
	{
		echo 1;
	}

	public static function get()
	{
		self::test();
	}
}

class B extends A
{
	public static function test()
	{
		echo 2;
	}
}

B::get(); // 1
    </code>
</pre>
<h2>Модификаторы доступа</h2>
<ul>
    <li><b><em>public</em></b> - можно использовать везде.
    </li>
    <li><b><em>protected</em></b> - этот спецификатор означает, что свойства и методы могут использоваться только внутри
        самого класса и внутри дочернего класса..
    </li>
    <li><b><em>private</em></b> - Этот спецификатор доступа говорит о том, что свойство или метод объекта может быть
        использован(о) только внутри методов этого же класса. Т.е. оно является закрытым от внешнего кода.
    </li>
</ul>

<h2>Клонирование</h2>
<p>Если переменная содержит объект, то на самом деле она содержит ссылку на область памяти, где хранится объект.</p>
<p><b><em>Клонирование объекта</em></b> - это создание еще одного экземпляра класса, идентичного данному объекту. Для
    этого используется
    специальное ключевое слово clone, после которого необходимо указать объект, который будет клонирован. Эта
    конструкция вернет новый экземпляр класса.
</p>

<h2>Магические методы</h2>
<p><b><em>Магические методы</em></b> - это методы, которые вызываются неявно. А именно - они вызываются автоматически,
    при некоторых условиях
</p>
<p><b><em>Конструкторы и деструкторы</em></b> - это магические методы, которые вызываются при создании объекта и
    удалении его из памяти соответственно. Конструкторы автоматически не вызываються у родительского класса.
</p>
<p><b><em>__clone()</em></b> - будет автоматически вызвана при клонировании объекта, если она определена в
    соответствующем классе..
</p>
<p><b><em>__get($name)</em></b> - будет автоматически вызвана при попытке использования (но не присвоения этому свойству
    значения) private свойства вне класса или просто неопределенного свойства объекта. При этом функция принимает в
    качестве аргумента переменную, в которую будет подставлено название свойства.
</p>
<p><b><em>__clone()</em></b> - будет автоматически вызвана при клонировании объекта, если она определена в
    соответствующем классе..
</p>
<p><b><em>__set($name, $val)</em></b> - будет автоматически вызвана при попытке присвоения значения private свойству вне
    класса или просто неопределенному свойству объекта. При этом функция принимает в качестве аргументов переменные, в
    которые будет подставлено название свойства и его значение.
</p>
<p><b><em>__call($name, $arguments)</em></b> - будет вызван при попытке вызова private метода объекта или
    неопределенного метода в классе. Он принимает аргументы в виде названия метода и переданных значений в этот метод.
</p>
<p><b><em>__callStatic($name, $arguments)</em></b> -будет вызван при попытке вызова статического private метода объекта
    или неопределенного метода в классе в статическом контексте. Он принимает аргументы в виде названия метода и
    переданных значений в этот метод. Также, он должен быть определен как статический.
</p>
<p><b><em>_isset($name), __unset($name)</em></b> -будут автоматически вызваны при попытке применить функции issetили
    unset(соответственно) к privateили неопределенным свойствам объекта.
</p>
<p><b><em>__sleep()</em></b> -будет автоматически вызван перед сериализацией объекта. Этот метод должен вернуть массив
    из названий public свойств объекта, которые будут сериализованы.
</p>
<p><b><em>__wakeup()</em></b> -будет автоматически вызван перед восстановлением объекта после сериализации.
</p>
<p><b><em>__toString()</em></b> - будет вызван автоматически при попытке привести объект к строке.
</p>
<p><b><em>__invoke()</em></b> -будет вызван при попытке использовать объект как функцию- т.е. выполнить вызов.
</p>

<h2> Магические константы и полезные функции</h2>
<p>
    Константа <b><em>__CLASS__</em></b> содержит название класса, в котором она была использована.
</p>
<p>
    Константа<b><em> __METHOD__</em></b> содержит название метода, в котором она была использована.
</p>

<p>
    Рассмотрим некоторые полезные функции для работы с классами: <b><em>class_exists(), get_class(), method_exists(),
            property_exists().</em></b>
<p>
    Функции class_exists($className), method_exists($className, $methodName), property_exists($className, $varName)
    проверяют, определен ли: класс с указанным названием, определен ли метод с указанным названием в указанном классе,
    определено ли свойство в указанном классе (соответственно).
</p>
<p>
    Функция get_class($obj) возвращает название класса по указанной ссылке на соответствующий объект.
</p>

<h2> Абстрактные классы и методы</h2>
<p>
    <b><em>Абстрактный класс</em></b> - это класс, для которого не могут быть созданы его экземпляры. Для того, чтоб
    определить класс, как абстрактный, необходимо записать ключевое слово abstract перед словом class.<br>
    Тогда любая попытка создать экземпляр этого класса (при помощи оператора new) будет означать fatal error и работа
    скрипта будет остановлена.
</p>
<p>
    Методы, объявленные абстрактными, несут, по существу, лишь описательный смысл и не могут включать реализацию.
    При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть
    определены в дочернем классе; кроме того, область видимости этих методов должна совпадать (или быть менее строгой).
    Например, если абстрактный метод объявлен как protected, то реализация этого метода должна быть protected или
    public, но не private. Более того, объявления методов должны совпадать, то есть контроль типов (type hint) и
    количество обязательных аргументов должно быть одинаковым. К примеру, если в дочернем классе указан необязательный
    параметр, которого нет в объявлении абстрактного класса, то в данном случае конфликта объявлений методов не будет.
</p>
<p>
    <b><em>Для чего это нужно?</em></b> Это дает программистам более качественно моделировать те или иные сущности.
    Например, у нас есть геометрическая фигура и класс Figure. Поскольку, мы еще не знаем, какая именно фигура, то мы не
    можем ее себе представить или нарисовать. Это значит что создавать экземпляр этого класса не имеет смысла и мы можем
    определить соответствующий класс как абстрактный, а классы Triangle, Square, CIrcle как дочерние классы
    геометрической фигуры.
</p>
<h2> Финальные классы и методы</h2>
<p>
    Ключевое слово final перед определением класса означает, что этот класс не может иметь дочерних классов - т.е.
    является финальным в смысле наследования.
    Финальными могут быть также и методы класса. Ключевое слово final в этом случае необходимо записать перед
    определением метода. Это означает, что в дочернем классе соответствующий метод не может быть переопределен.
</p>

<h2>Интерфейсы</h2>
<p>
    <b><em>Интерфейсы</em></b> объектов позволяют создавать код, который указывает, какие методы должен реализовать
    класс, без необходимости определять, как именно они должны быть реализованы.
</p>
<p>
    Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова interface вместо class.
    Тела методов интерфейсов должны быть пустыми.
</p>
<p>
    Все методы, определенные в интерфейсах должны быть общедоступными, что следует из самой природы интерфейса.
</p>
<p>
    Для реализации интерфейса используется оператор implements. Класс должен реализовать все методы, описанные в
    интерфейсе, иначе произойдет фатальная ошибка. При желании классы могут реализовывать более одного интерфейса,
    разделяя каждый интерфейс запятой.
</p>
<p>
    Интерфейсы могут содержать константы. Константы интерфейсов работают точно так же, как и константы классов, за
    исключением того, что они не могут быть переопределены наследующим классом или интерфейсом.
</p>
<h2>В чем отличие интерфейса от абстрактного класса?</h2>
<p>
 Для интерфейсов, как и для абстрактных классов нельзя создать экземпляры. Отличие абстрактного класса от интерфейса
    состоит в том, что в интерфейсе необходимо опускать тело всех методов, а абстрактный метод может содержать
    реализацию отдельных методов. Также для классов невозможно множественное наследование, в отличии от интерфейсов.
</p>

<h2>Traits</h2>
<p>
    Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного наследования,
    таких как PHP. Трейт предназначен для уменьшения некоторых ограничений одиночного наследования, позволяя
    разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и реализованных с
    использованием разных архитектур построения классов. Семантика комбинации трейтов и классов определена таким
    образом, чтобы снизить уровень сложности, а также избежать типичных проблем, связанных с множественным наследованием
    и смешиванием (mixins).
</p>

<p>
    Трейт очень похож на класс, но предназначен для группирования функционала хорошо структурированым и последовательным
    образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию и позволяет
    сделать горизонтальную композицию поведения, то есть применение членов класса без необходимости наследования.
</p>
<p>
    Если два трейта вставляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт
    явно не разрешен.<br>
    Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать
    оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.
</p>
<p>
    В этом примере Talker использует трейты A и B. Так как в A и B есть конфликтующие методы, он определяет использовать
    вариант smallTalk из трейта B, а вариант bigTalk - из трейта A.<br>
    Класс Aliased_Talker применяет оператор as чтобы получить возможность использовать имплементацию bigTalk из B под
    дополнительным псевдонимом talk.
</p>
<pre>
    <code class="php">
        trait A {
            public function smallTalk() {
                echo 'a';
            }
            public function bigTalk() {
                echo 'A';
            }
        }

        trait B {
            public function smallTalk() {
                echo 'b';
            }
            public function bigTalk() {
                echo 'B';
            }
        }

        class Talker {
            use A, B {
                B::smallTalk insteadof A;
                A::bigTalk insteadof B;
            }
        }

        class Aliased_Talker {
            use A, B {
                B::smallTalk insteadof A;
                A::bigTalk insteadof B;
                B::bigTalk as talk;
            }
        }
    </code>
</pre>
<p>
    Пример #6 Пример изменения видимости метода
</p>
<pre>
    <code class="php">
        trait HelloWorld {
            public function sayHello() {
                echo 'Hello World!';
            }
        }

        // Изменение видимости метода sayHello
        class MyClass1 {
            use HelloWorld { sayHello as protected; }
        }

        // Создание псевдонима метода с измененной видимостью
        // видимость sayHello не изменилась
        class MyClass2 {
            use HelloWorld { sayHello as private myPrivateHello; }
        }
    </code>
</pre>

<h2>Исключение</h2>
<p>
    <b><em>Исключение</b></em> - это действие, которое не укладывается в работу приложения. Исключения используют для
    того, чтобы
    корректно обрабатывать ошибки, возникающие в коде программы. Как правило к исключениям применяется терминология
    бросить-поймать. Исключение бросается в том месте кода, когда ошибка неизбежна. Это, в свою очередь, означает, что
    оно должно быть поймано - т.е. обработано.
</p>