<h2>
    Строитель
    <a class="btn btn-secondary" target="_blank"
       href="https://refactoring.guru/ru/design-patterns/builder">
        refactoring.guru
    </a>
    <a class="btn btn-secondary" target="_blank"
       href="https://tproger.ru/translations/design-patterns-simple-words-1/#14">
        Интересный пример
    </a>
</h2>
<p><b>Строитель</b> — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
    Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
</p>
<p>
    <b>Проблема</b>давайте подумаем о том, как создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4
    стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее,
    имеющий сад, бассейн и прочее добро?
</p>
<p>
    Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. Проблема такого
    подхода — это громадное количество классов, которые вам придётся создать.
</p>
<p>
    Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор
    Дома, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от
    подклассов, но приведёт к другой проблеме.
</p>
<pre>
    <code class="php">
        new House(4,2,4,true,null,null,null,...);
        new House(4,2,4,true,true,true,true,...);
    </code>
</pre>
<p>
    Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного
    списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут
    простаивать бесполезно в 99% случаев.
</p>
<p>
    <b>Решение</b> Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса,
    разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). Чтобы
    создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что
    нужны для производства объекта определённой конфигурации.
</p>
<p>
    Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. Например,
    деревянный дом потребует строительства стен из дерева, а каменный — из камня.
</p>
<p>
    В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. Используя
    этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.
</p>

<p>
    Например, один строитель делает стены из дерева и стекла, другой из камня и железа, третий из золота и бриллиантов.
    Вызвав одни и те же шаги строительства, в первом случае вы получите обычный жилой дом, во втором — маленькую
    крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает шаги строительства, должен работать со
    строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.
</p>

<p>
    Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае
    директор будет задавать порядок шагов строительства, а строитель — выполнять их.

    Директор знает, какие шаги должен выполнить объект-строитель, чтобы произвести продукт.

    Отдельный класс директора не является строго обязательным. Вы можете вызывать методы строителя и напрямую из
    клиентского кода. Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов,
    отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном
    классе.

    Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов. Клиенту останется
    только привязать желаемого строителя к директору, а затем получить у строителя готовый результат.
</p>


<h3>Пример из реальной жизни</h3>
<p>
    Одним из лучших применений паттерна <b>Строитель</b> является конструктор запросов SQL. Интерфейс Строителя
    определяет общие шаги, необходимые для построения основного SQL-запроса. В тоже время Конкретные Строители,
    соответствующие различным диалектам SQL, реализуют эти шаги, возвращая части SQL-запросов, которые могут быть
    выполнены в данном движке базы данных.
</p>

<pre>
    <code class="php">
        <?php
        require_once app()->getBasePath('Models/Front/Info/Patterns/Creational/Builder_1.php');
        ?>
    </code>
</pre>

<h3>Пример из реальной жизни</h3>
<p>
    Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних
    вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов.
    Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой
    хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».
</p>

<p>
    <b>Простыми словами:</b> Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он
    полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.
</p>

<pre>
    <code class="php">
        <?php
        require_once app()->getBasePath('Models/Front/Info/Patterns/Creational/Builder_2.php');
        ?>
    </code>
</pre>