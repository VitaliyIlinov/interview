<h2>
    Фабричный метод
    <a class="btn btn-secondary" target="_blank"
       href="https://refactoring.guru/ru/design-patterns/factory-method/php/example">
        refactoring.guru
    </a>
</h2>

<p>
    Это порождающий паттерн проектирования, который решает проблему создания различных продуктов, без указания
    конкретных классов продуктов.
</p>
<p>
    Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания
    объектов-продуктов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.
</p>
<p>
    <b>Проблема</b> Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете
    перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик. В какой-то
    момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят
    добавить поддержку морской логистики в программу.
</p>
<p>
    Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам
    Грузовиков. Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу. Более того,
    если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

    В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в
    зависимости от класса транспорта.
</p>
<p>
    Решение Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов
    особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, но делать это будет
    фабричный метод.
</p>
<p>
    <b>Пример из жизни</b>: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования
    со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между
    разными людьми.<br> <b>Простыми словами</b>: данный шаблон делегирует создание объектов наследникам родительского
    класса
</p>
<pre>
    <code class="php">
        <?= $content ?>
    </code>
</pre>
<p>
    <b>Когда использовать</b>: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс
    динамически определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может
    понадобиться.
</p>