<h2>Краткий обзор Индексов таблиц MySQL</h2>
<p>Источники&raquo;
    <a class="btn btn-secondary" target="_blank"
       href="https://ruhighload.com/%D0%9A%D0%B0%D0%BA+%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE+%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C+%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql%3F"
       role="button">
        ruhighload
    </a>
    <a class="btn btn-secondary" target="_blank"
       href="https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql" role="button">
        ruhighload
    </a>
    <a class="btn btn-secondary" target="_blank"
       href="https://devionity.com/ru/courses/mysql-fundamentals/normalization" role="button">
        devionity
    </a>
</p>
<p>
    <b>Система управления базами данных</b> - это программное обеспечение для работы с самими базами данных. Иными
    словами это
    программа. Основное предназначение СУБД - это поддержка и разработка баз данных. СУБД, которые работают с
    реляционными базами данных называются реляционными СУБД
</p>
<p>
    <b>Индекс таблицы</b> - это специальный объект БД, который создается СУБД. Индекс таблицы позволяет оптимизировать и
    ускорить работу с таблицей базы данных. В самом простом случае, индекс необходимо создавать для тех колонок, которые
    присутствуют в условии WHERE. <br>CREATE INDEX age ON users(age);
</p>

<h2>Класификация индексов</h2>
<ul>
    <li>
        <b>Primary</b> - это поле, значения которого позволяют отличать разные записи друг от друга, делают их
        уникальными. Значения первичного поля не допускают повторений в своих значениях.
    </li>
    <li><b>UNIQUE</b> -Это удобно для колонок, значения в которых должны быть уникальными по всей таблице. Такие индексы
        улучшают эффективность выборки для уникальных значений
    </li>
    <li><b>INDEX</b> - простые индексы
    </li>
</ul>


<h2>Составные индексы</h2>
<p>
    Индексы могут быть составными, если критерий содержит несколько полей таблицы. Очередность колонок в индексе будет
    играть большую роль
</p>
<p>
    Пример<br><br>
    mysql> SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2<br><br>
    Если по столбцам col1 и col2 существует многостолбцовый индекс, то соответствующие строки могут выбираться напрямую.
    В случае, когда по столбцам col1 и col2 существуют раздельные индексы, оптимизатор пытается найти наиболее
    ограничивающий индекс путем определения, какой индекс найдет меньше строк, и использует данный индекс для выборки
    этих строк.
</p>
<p>Если данная таблица имеет многостолбцовый индекс, то любой крайний слева префикс этого индекса может использоваться
    оптимизатором для нахождения строк. Например, если имеется индекс по трем столбцам (col1,col2,col3), то существует
    потенциальная возможность индексированного поиска по (col1), (col1,col2) и (col1,col2,col3).
</p>

<h2>Селективность индексов</h2>
<pre>
    <code>
        mysql> select age, count(*) from users group by age;
        +------+----------+
        | age  | count(*) |
        +------+----------+
        |   15 |      160 |
        |   16 |      250 |
        |        ...      |
        |   76 |      210 |
        |   85 |      230 |
        +------+----------+
        68 rows in set (0.00 sec)

        mysql> select gender, count(*) from users group by gender;
        +--------+----------+
        | gender | count(*) |
        +--------+----------+
        | female |     8740 |
        | male   |     4500 |
        +--------+----------+
    </code>
</pre>
<p>
    Эта информация говорит нам вот о чем:
</p>
<ul>
    <li>Любое значение колонки age обычно содержит около 200 записей.</li>
    <li>Любое значение колонки gender — около 6000 записей.</li>
</ul>
<p>
    Если колонка age будет идти первой в индексе, тогда MySQL после первой части индекса сократит количество записей до
    200. Останется сделать выборку по ним. Если же колонка gender будет идти первой, то количество записей будет
    сокращено до 6000 после первой части индекса. Т.е. на порядок больше, чем в случае age.

</p>
<p>Это значит, что индекс age_gender будет работать лучше, чем gender_age.</p>
<p>
    <b>Селективность</b> колонки определяется количеством записей в таблице с одинаковыми значениями. Когда записей с
    одинаковым значением мало — селективность высокая. Такие колонки необходимо использовать первыми в составных
    индексах.
</p>

<h2>Когда создавать индексы?</h2>
<ul>
    <li>
        Индексы следует создавать по мере обнаружения медленных запросов. В этом поможет slow log в MySQL. Запросы,
        которые выполняются более 1 секунды являются первыми кандидатами на оптимизацию.
    </li>
    <li>Начинайте создание индексов с самых частых запросов. Запрос, выполняющийся секунду, но 1000 раз в день наносит
        больше ущерба, чем 10-секундный запрос, который выполняется несколько раз в день.
    </li>
    <li>Не создавайте индексы на таблицах, число записей в которых меньше нескольких тысяч. Для таких размеров выигрыш
        от использования индекса будет почти незаметен.
    </li>
    <li>Не создавайте индексы заранее, например, в среде разработки. Индексы должны устанавливаться исключительно под
        форму и тип нагрузки работающей системы.
    </li>
    <li>Удаляйте неиспользуемые индексы.</li>
</ul>

<h2> Создание индексов</h2>
<pre>
    <code>
    ALTER TABLE student ADD INDEX(age);
    </code>
</pre>
<p>Для просмотра информации по индексам необходимо исполнить запрос</p>
<pre>
    <code>
    SHOW INDEX FROM student;
    </code>
</pre>
<p>Для удаления индекса необходимо исполнить запрос</p>
<pre>
    <code>
    DROP INDEX age ON student;
    </code>
</pre>


<h2>Внешний ключ</h2>
<p>
    Это поле (или набор полей), значения которого берутся из другой таблицы. Таким образом устанавливается связь между
    разными таблицами. Основным предназначением внешнего ключа является поддержка целостности данных, которые сохранены
    в разных таблицах.
</p>
<p>
    Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой,
    подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на
    первичный ключ из связанной главной таблицы.
</p>

<h2> Создание внешних ключей</h2>
<p>
    Общий синтаксис установки внешнего ключа на уровне таблицы:
</p>
<pre>
    <code>
    [CONSTRAINT имя_ограничения]
    FOREIGN KEY (столбец1, столбец2, ... столбецN)
    REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
    [ON DELETE действие]
    [ON UPDATE действие]
    </code>
</pre>
<p>
    Для создания ограничения внешнего ключа после <b>FOREIGN KEY</b> указывается столбец таблицы, который будет
    представляет внешний ключ. А после ключевого слова <b>REFERENCES</b> указывается имя связанной таблицы, а затем в
    скобках имя
    связанного столбца, на который будет указывать внешний ключ. После выражения <b>REFERENCES</b> идут выражения <b>ON
        DELETE</b>
    и <b>ON UPDATE</b>,
    которые задают действие при удалении и обновлении строки из главной таблицы соответственно.
</p>
<p>
    Например, определим две таблицы и свяжем их посредством внешнего ключа:
</p>
<pre>
    <code>
    CREATE TABLE Customers
    (
        Id INT PRIMARY KEY AUTO_INCREMENT,
        Age INT,
        FirstName VARCHAR(20) NOT NULL,
        LastName VARCHAR(20) NOT NULL,
        Phone VARCHAR(20) NOT NULL UNIQUE
    );

    CREATE TABLE Orders
    (
        Id INT PRIMARY KEY AUTO_INCREMENT,
        CustomerId INT,
        CreatedAt Date,
        FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
    );
    </code>
</pre>

<p>
    В данном случае определены таблицы Customers и Orders. Customers является главной и представляет клиента. Orders
    является зависимой и представляет заказ, сделанный клиентом. Таблица Orders через столбец CustomerId связана с
    таблицей Customers и ее столбцом Id. То есть столбец CustomerId является внешним ключом, который указывает на
    столбец Id из таблицы Customers
</p>

<p>
    С помощью оператора <b>CONSTRAINT</b> можно задать имя для ограничения внешнего ключа:
</p>
<pre>
    <code>
    CREATE TABLE Orders
    (
        Id INT PRIMARY KEY AUTO_INCREMENT,
        CustomerId INT,
        CreatedAt Date,
        CONSTRAINT orders_custonmers_fk
        FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
    );
    </code>
</pre>

<h3>ON DELETE и ON UPDATE</h3>
<p>
    С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении
    и изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:
</p>
<ul>
    <li>
        <b>CASCADE</b>: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении
        связанных
        строк в главной таблице.
    </li>
    <li>
        <b>SET NULL</b>: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца
        внешнего
        ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)
    </li>
    <li>
        <b>NO ACTION</b>: то же самое, что и RESTRICT.
    </li>
    <li>
        <b>RESTRICT</b>: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в
        зависимой
        таблице.
    </li>
    <li>
        <b>SET DEFAULT</b>: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа
        значение
        по умолчанию, которое задается с помощью атрибуты DEFAULT. Несмотря на то, что данная опция в принципе доступна,
        однако движок InnoDB не поддерживает данное выражение.
    </li>
</ul>

<h3>Каскадное удаление</h3>
<p>
    Каскадное удаление позволяет при удалении строки из главной таблицы автоматически удалить все связанные строки из
    зависимой таблицы. Для этого применяется опция <b>CASCADE:</b>
</p>

<pre>
    <code>
    CREATE TABLE Orders
    (
        Id INT PRIMARY KEY AUTO_INCREMENT,
        CustomerId INT,
        CreatedAt Date,
        FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
    );
    </code>
</pre>

<p>
    Подобным образом работает и выражение <b>ON UPDATE CASCADE</b>. При изменении значения первичного ключа
    автоматически
    изменится значение связанного с ним внешнего ключа. Однако поскольку первичные ключи изменяются очень редко, да и с
    принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике
    выражение ON UPDATE используется редко.
</p>

<h3>Установка NULL</h3>
<p>
    При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:
</p>
<pre>
    <code>
    CREATE TABLE Orders
    (
        Id INT PRIMARY KEY AUTO_INCREMENT,
        CustomerId INT,
        CreatedAt Date,
        FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
    );
    </code>
</pre>
