<h2>Краткий обзор Индексов таблиц MySQL</h2>
<p>Источники&raquo;
    <a class="btn btn-secondary" target="_blank"
       href="https://ruhighload.com/%D0%9A%D0%B0%D0%BA+%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE+%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C+%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql%3F"
       role="button">
        ruhighload
    </a>
    <a class="btn btn-secondary" target="_blank"
       href="https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql" role="button">
        ruhighload
    </a>
    <a class="btn btn-secondary" target="_blank"
       href="https://devionity.com/ru/courses/mysql-fundamentals/normalization" role="button">
        devionity
    </a>
</p>
<p>
    <b>Система управления базами данных</b> - это программное обеспечение для работы с самими базами данных. Иными
    словами это
    программа. Основное предназначение СУБД - это поддержка и разработка баз данных. СУБД, которые работают с
    реляционными базами данных называются реляционными СУБД
</p>
<p>
    <b>Индекс таблицы</b> - это специальный объект БД, который создается СУБД. Индекс таблицы позволяет оптимизировать и
    ускорить работу с таблицей базы данных. В самом простом случае, индекс необходимо создавать для тех колонок, которые
    присутствуют в условии WHERE. <br>CREATE INDEX age ON users(age);
</p>

<h2>Класификация индексов</h2>
<ul>
    <li>
        <b>Primary</b> - это поле, значения которого позволяют отличать разные записи друг от друга, делают их
        уникальными. Значения первичного поля не допускают повторений в своих значениях.
    </li>
    <li><b>UNIQUE</b> -Это удобно для колонок, значения в которых должны быть уникальными по всей таблице. Такие индексы
        улучшают эффективность выборки для уникальных значений
    </li>
    <li><b>INDEX</b> - простые индексы
    </li>
</ul>


<h2>Составные индексы</h2>
<p>
    Индексы могут быть составными, если критерий содержит несколько полей таблицы. Очередность колонок в индексе будет
    играть большую роль
</p>
<p>
    Пример<br><br>
    mysql> SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2<br><br>
    Если по столбцам col1 и col2 существует многостолбцовый индекс, то соответствующие строки могут выбираться напрямую.
    В случае, когда по столбцам col1 и col2 существуют раздельные индексы, оптимизатор пытается найти наиболее
    ограничивающий индекс путем определения, какой индекс найдет меньше строк, и использует данный индекс для выборки
    этих строк.
</p>
<p>Если данная таблица имеет многостолбцовый индекс, то любой крайний слева префикс этого индекса может использоваться
    оптимизатором для нахождения строк. Например, если имеется индекс по трем столбцам (col1,col2,col3), то существует
    потенциальная возможность индексированного поиска по (col1), (col1,col2) и (col1,col2,col3).</p>
<h2>Селективность индексов</h2>
<p>
    <b>Селективность</b> колонки определяется количеством записей в таблице с одинаковыми значениями. Когда записей с
    одинаковым значением мало — селективность высокая. Такие колонки необходимо использовать первыми в составных
    индексах.
</p>
<table class="table table-bordered table-hover">
    <thead>
    <tr>
        <th scope="col">age</th>
        <th scope="col"><b>count(*)</b></th>
        <th scope="col"><b>||||</b></th>
        <th scope="col"><b>gender</b></th>
        <th scope="col"><b>count(*)</b></th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>15</td>
        <td>160</td>
        <td>||||</td>
        <td>female</td>
        <td>8740</td>
    </tr>
    <tr>
        <td>16</td>
        <td>160</td>
        <td>||||</td>
        <td>male</td>
        <td>4500</td>
    </tr>
    <tr>
        <td>76</td>
        <td>210</td>
        <td>||||</td>
        <td>some</td>
        <td>4000</td>
    </tr>
    </tbody>
</table>
<p>
    Если колонка age будет идти первой в индексе, тогда MySQL после первой части индекса сократит количество записей до
    200. Останется сделать выборку по ним. Если же колонка gender будет идти первой, то количество записей будет
    сокращено до 6000 после первой части индекса. Т.е. на порядок больше, чем в случае age.
    Это значит, что индекс age_gender будет работать лучше, чем gender_age.
</p>

<h2>Когда создавать индексы?</h2>
<ul>
    <li>
        Индексы следует создавать по мере обнаружения медленных запросов. В этом поможет slow log в MySQL. Запросы,
        которые выполняются более 1 секунды являются первыми кандидатами на оптимизацию.
    </li>
    <li>Начинайте создание индексов с самых частых запросов. Запрос, выполняющийся секунду, но 1000 раз в день наносит
        больше ущерба, чем 10-секундный запрос, который выполняется несколько раз в день.
    </li>
    <li>Не создавайте индексы на таблицах, число записей в которых меньше нескольких тысяч. Для таких размеров выигрыш
        от использования индекса будет почти незаметен.
    </li>
    <li>Не создавайте индексы заранее, например, в среде разработки. Индексы должны устанавливаться исключительно под
        форму и тип нагрузки работающей системы.
    </li>
    <li>Удаляйте неиспользуемые индексы.</li>
</ul>

<h2>Внешний ключ</h2>
<p>
    Это поле (или набор полей), значения которого берутся из другой таблицы. Таким образом устанавливается связь между
    разными таблицами. Основным предназначением внешнего ключа является поддержка целостности данных, которые сохранены
    в разных таблицах.
</p>
